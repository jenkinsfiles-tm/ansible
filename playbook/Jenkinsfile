#!groovy

pipeline {

  agent any

  parameters {
    string(
      name: 'ANSIBLE_PLAYBOOK',
      defaultValue: '',
      description: 'File name of Ansible playbook'
    )
    string(
      name: 'EXTRA_ARGS',
      defaultValue: '',
      description: 'Ansible playbook extra arguments'
    )
    string(
      name: 'GIT_BRANCHES_ANSIBLE',
      defaultValue: '*/master',
      description: "Git branch or tag name or commit id to retrieve of GIT_URL to retrieve Ansible playbook"
    )
    string(
      name: 'GIT_URL',
      defaultValue: '',
      description: "GitHub URL to retrieve Ansible playbook"
    )
    string(
      name: 'INVENTORY_PARAMS',
      defaultValue: '',
      description: 'ansible-playbook command inventory parameters'
    )
    string(
      name: 'SSH_PRIVATEKEY_PATH',
      defaultValue: '',
      description: 'SSH private key path, Ansible use it for connecting to the remote system. Default value: ~/.ssh/id_rsa'
    )
    string(
      name: 'WORKING_DIR',
      defaultValue: 'git-repo',
      description: 'Job working directory'
    )
  }

  stages {
    stage('Retrieve Ansible playbook from Github') {
      steps {
        checkout(
          [
            $class: 'GitSCM',
            branches: [
              [
                name: "${params.GIT_BRANCHES_ANSIBLE}"
              ]
            ],
            extensions: [
              [
                $class: 'RelativeTargetDirectory',
                relativeTargetDir: "${params.WORKING_DIR}"
              ]
            ],
            doGenerateSubmoduleConfigurations: false,
            submoduleCfg: [],
            userRemoteConfigs: [
              [
                url: "${params.GIT_URL}"
              ]
            ]
          ]
        )
      }
    }

    stage('Create ansible.cfg file') {
      steps {
        dir ("${params.WORKING_DIR}") {
            sh "echo '[defaults]' > ansible.cfg"
            sh "echo 'host_key_checking = False' >> ansible.cfg"
        }
      }
    }

    stage('Execute ansible-playbook command') {
      steps {
        dir ("${params.WORKING_DIR}") {
          script {
            def private_key_path = "${params.SSH_PRIVATEKEY_PATH}"

            if (private_key_path.length() == 0) {
              sh "ansible-playbook ${params.ANSIBLE_PLAYBOOK} \
                  ${params.INVENTORY_PARAMS} \
                  ${params.EXTRA_ARGS} \
                  | tee ansible.log"
            } else {
              sh "ansible-playbook ${params.ANSIBLE_PLAYBOOK} \
                  ${params.INVENTORY_PARAMS} \
                  --private-key=${params.SSH_PRIVATEKEY_PATH} \
                  ${params.EXTRA_ARGS} \
                  | tee ansible.log"
            }
          }
        }
      }
    }

    stage('Analyze ansible log') {
      steps {
        dir ("${params.WORKING_DIR}") {
          script {
            def output = sh(
                            returnStdout: true,
                            script: "tail -n 2 ansible.log"
                         )

            if (output.contains("unreachable=0") && output.contains("failed=0")) {
              sh "echo success"
            } else {
              error "ansible-playbook error\n$output"
            }
          }
        }
      }
    }
  }
}
